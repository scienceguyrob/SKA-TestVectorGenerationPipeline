"""
    ***************************************************************************************
    |                                                                                     |
    |                    Generate Tempo 2 predictor Files Version 2.0                     |
    |                                                                                     |
    ***************************************************************************************
    | Description:                                                                        |
    |                                                                                     |
    | Generates Tempo2 predictor files, for all PAR files in a user specified directory.  |
    | The predictor files are stored in a user defined output directory. This script will |
    | ONLY run on the .par files output by the CreateFakeParFiles.py python script. These |
    | have a specific file name format which this script expects. You are free to create  |
    | your own .par files manually for use with this script, though these must adhere to  |
    | the file name format described in the pre-requisites section below.                 |
    |                                                                                     |
    | Note: this script will over write existing predictor files during the generation    |
    | process.                                                                            |
    |                                                                                     |
    |                                                                                     |
    | Predictor files generated by this script will adhere to the file name format:       |
    |                                                                                     |
    | <ID>_DM=<DM>_P0=<P0>ms_OBS=<Obs>s_F1=<F1>_F2=<F2>_T=<TC>_F=<FC>_Z=<Accel>.dat       |
    |                                                                                     |
    | where <ID> is a string that uniquely identifies the .dat file, <DM> is a float      |
    | representing the dispersion measure, <PO> is a float representing the period in     |
    | milliseconds, <Obs> is an integer representing the observation length in seconds,   |
    | <F1> and <F2> are floats representing the frequency in MHz of the first and the     |
    | last channel respectively, <TC> is an integer corresponding to the number of        |
    | time coefficients used in Tempo2, whilst <FC> is similarly defined but for the      |
    | frequency coefficients, and finally <Accel> is a float that describes the           |
    | acceleration in m/s/s.                                                              |
    |                                                                                     |
    ***************************************************************************************
    | Pre-requisites:                                                                     |
    ***************************************************************************************
    |                                                                                     |
    | 1. The user has generated Tempo2 compatible .par files using the script             |
    |    CreateFakeParFiles.py to create valid .par files. The .par files should adhere   |
    |    to the following filename format:                                                |
    |                                                                                     |
    |    FakePulsar<Number>_DM=<DM>_P0=<P0>ms_Z=<Accel>.par                               |
    |                                                                                     |
    |    Where <Number> is an integer that helps identify the par file, <DM> is a float   |
    |    representing the dispersion measure, <PO> is a float representing the period in  |
    |    milliseconds, and <Accel> is a float that describes the acceleration in m/s/s.   |
    |                                                                                     |
    | 2. Valid .par files that adhere to the naming standards mentioned above, are stored |
    |    in a directory whose path is provided by the user at runtime.                    |
    |                                                                                     |
    ***************************************************************************************
    | Required Arguments:                                                                 |
    ***************************************************************************************
    |                                                                                     |
    | -p (string) full path to the directory containing par files.                        |
    |                                                                                     |
    | -d (string) full path to an output directory to store predictor files in.           |
    |                                                                                     |
    ***************************************************************************************
    | Optional Arguments:                                                                 |
    ***************************************************************************************
    |                                                                                     |
    | -v (boolean) verbose logging flag.                                                  |
    |                                                                                     |
    | -s (int) the length of the observation in seconds to be passed in to Tempo2 for     |
    |          predictor file creation (default=600).                                     |
    |                                                                                     |
    | --f1 (float) the frequency of the first channel which is passed in to Tempo2 for    |
    |              predictor file creation (default=1350).                                |
    |                                                                                     |
    | --f2 (float) the frequency of the last channel which is passed in to Tempo2 for     |
    |              predictor file creation (default=1670).                                |
    |                                                                                     |
    | --tcoeff (int) the number of time coefficients to be computed by Tempo2 during      |
    |                predictor file creation (default=12).                                |
    |                                                                                     |
    | --fcoeff (int) the number of frequency coefficients to be computed by Tempo2 during |
    |                predictor file creation (default=2).                                 |
    |                                                                                     |
    | --mjd1 (float) the start time mjd used by Tempo2 during predictor file creation     |
    |                (default=56000).                                                     |
    |                                                                                     |
    | --mjd2 (float) the end time mjd used by Tempo2 during predictor file creation       |
    |                (default=56001).                                                     |
    |                                                                                     |
    | --tel (string) the telescope the simulated pulsar observation corresponds to. By    |
    |                default this is set to "PARKES". Valid values include, but are not   |
    |                limited to,                                                          |
    |                                                                                     |
    |                GBT                                                                  |
    |                ARECIBO                                                              |
    |                JODRELL                                                              |
    |                LOFAR                                                                |
    |                MEERKAT                                                              |
    |                EFFELSBERG                                                           |
    |                NANCAY                                                               |
    |                MEERKAT                                                              |
    |                GMRT                                                                 |
    |                KAT-7                                                                |
    |                WSRT                                                                 |
    |                VLA                                                                  |
    |                                                                                     |
    |                See the observatories.dat file of Tempo2 for other                   |
    |                valid telescope codes.                                               |
    |                                                                                     |
    ***************************************************************************************
    | Author: Rob Lyon                                                                    |
    | Email : robert.lyon@manchester.ac.uk                                                |
    | web   : www.scienceguyrob.com                                                       |
    ***************************************************************************************
    | License:                                                                            |
    ***************************************************************************************
    |                                                                                     |
    | Code made available under the GPLv3 (GNU General Public License), that allows you   |
    | to copy, modify and redistribute the code as you see fit:                           |
    | (http://www.gnu.org/copyleft/gpl.html).                                             |
    | Though a mention to the original author using the citation above in derivative      |
    | works, would be very much appreciated.                                              |
    ***************************************************************************************
"""

# Command line processing imports:
from optparse import OptionParser
import os
import datetime
import subprocess
from shutil import copyfile

# Custom files
from ParFile import ParFile
from PredFile import PredFile
from Common import Common


# ******************************
#
# CLASS DEFINITION
#
# ******************************


class GeneratePredictorFiles:
    """
    Description:

    Generates TEMPO2 predictor files for all PAR files in a user specified
    Directory. The predictor files are stored in a user defined output
    directory. This script is design to run on the par files output by the
    CreateFakeParFiles.py python script.

    Predictor files generated by this script will adhere to the file name format:

    <ID>_DM=<DM>_P0=<P0>ms_OBS=<Obs>s_F1=<F1>_F2=<F2>_T=<TC>_F=<FC>_Z=<Accel>.dat

    where <ID> is a string that uniquely identifies the .dat file, <DM> is a float
    representing the dispersion measure, <PO> is a float representing the period in
    milliseconds, <Obs> is an integer representing the observation length in seconds,
    <F1> and <F2> are floats representing the frequency in MHz of the first and the
    last channel respectively, <TC> is an integer corresponding to the number of
    time coefficients used in Tempo2, whilst <FC> is similarly defined but for the
    frequency coefficients, and finally <Accel> is a float that describes the
    acceleration in m/s/s.

    """

    def __init__(self):
        """
        Initialises the class and class variables.
        """
        self.verbose    = False  # Logging flag.
        self.par_dir    = ""     # The directory containing par files.
        self.output_dir = ""     # The directory to store predictor files in.
        self.obs_length = 0.0    # The length of the observation, passed to Tempo2.
        self.f1         = 0.0    # Frequency of first channel.
        self.f2         = 0.0    # Frequency of last channel.
        self.tcoeff     = 0      # The number of time coefficients to be computed by Tempo2.
        self.fcoeff     = 0      # The number of frequency coefficients to be computed by Tempo2.
        self.mjd1       = 0.0    # The start time mjd used by Tempo2.
        self.mjd2       = 0.0    # The end time mjd used by Tempo2.
        self.telescope  = ""     # The telescope name given to Tempo2.
        self.arguments  = []     # Used to store command line arguments supplied by the user.

    # ******************************************************************************************

    # ******************************
    #
    # MAIN METHOD AND ENTRY POINT.
    #
    # ******************************

    ##
    # The main method for the class. Main entry point for the Application.
    # Processes command line input and begins automating the creation of the
    # pulse profile.
    #
    #  @param self The object pointer.
    #  @param argv The unused arguments.
    def main(self, argv=None):
        """Main method.

        Main entry point for the Application. Processes command line
        input and begins automating the the creation of par files.

        Parameters
        ----------
        argv : str
            The unused arguments.

        """

        # ****************************************
        #         Execution information
        # ****************************************

        print(__doc__)

        # ****************************************
        #    Command line argument processing
        # ****************************************

        # Argument processing.
        parser = OptionParser()


        # REQUIRED ARGUMENTS

        parser.add_option("-p", action="store", dest="p", type=str,
                          help='Path to a directory containing par files.', default="")

        parser.add_option("-d", action="store", dest="d", type=str,
                          help='Path to the directory to store the predictor files in.', default="")

        # OPTIONAL ARGUMENTS

        parser.add_option("-v", action="store_true", dest="v",
                          help='Verbose debugging flag (optional).', default=False)

        parser.add_option("-s", dest="s", type=int,
                          help='The total of seconds to pass in to tempo2 (optional).', default=600)

        parser.add_option("--f1", dest="f1", type=float,
                          help='The frequency of the first channel passed in to tempo2 (optional).', default=1350.0)

        parser.add_option("--f2", dest="f2", type=float,
                          help='The frequency of the last channel passed in to tempo2 (optional).', default=1670.0)

        parser.add_option("--tcoeff", dest="tcoeff", type=int,
                          help='The number of time coefficients to be computed by tempo2 (optional).', default=12)

        parser.add_option("--fcoeff", dest="fcoeff", type=int,
                          help='The number of frequency coefficients to be computed by tempo2 (optional).', default=2)

        parser.add_option("--mjd1", action="store", dest="mjd1", type=float,
                          help='Start time MJD.', default=56000.0)

        parser.add_option("--mjd2", action="store", dest="mjd2", type=float,
                          help='End time MJD.', default=56001.0)

        parser.add_option("--tel", action="store", dest="t", type=str,
                          help='The telescope the observation corresponds to.', default="PARKES")

        (args, options) = parser.parse_args()

        # Update variables with command line parameters.
        try:
            self.verbose    = args.v
            self.par_dir    = args.p
            self.output_dir = args.d
            self.obs_length = args.s
            self.f1         = float(args.f1)
            self.f2         = float(args.f2)
            self.tcoeff     = args.tcoeff
            self.fcoeff     = args.fcoeff
            self.mjd1       = float(args.mjd1)
            self.mjd2       = float(args.mjd2)
            self.telescope  = args.t
        except ValueError:
            print("WARNING: Could not cast user provided parameters to float types...")

        # Pre-process arguments to make unit testing easier.
        self.arguments = [self.verbose, self.par_dir, self.output_dir, self.obs_length, self.f1,
                          self.f2, self.tcoeff, self.fcoeff, self.mjd1, self.mjd2, self.telescope]


        # ****************************************
        #   Print command line arguments
        # ****************************************

        print("\n\t**************************")
        print("\t| Command Line Arguments |")
        print("\t**************************")
        print("\tDebug: "                 + str(self.verbose))
        print("\tPar directory path: "    + str(self.par_dir))
        print("\tOutput directory path: " + str(self.output_dir))
        print("\tSegment length: "        + str(self.obs_length))
        print("\tF1 value: "              + str(self.f1))
        print("\tF2 value: "              + str(self.f2))
        print("\tNumber of time coefficients: "  + str(self.tcoeff))
        print("\tNumber of freq. coefficients: " + str(self.fcoeff))
        print("\tMJD 1: " + str(self.mjd1))
        print("\tMJD 2: " + str(self.mjd2))

        # Check the command line parameters are valid.
        if self.check_parameters(self.arguments):

            print("\n\t**************************")
            print("\t|     Par file search    |")
            print("\t**************************")
            print("\n\tSearching: " + str(self.par_dir))

            # Maintain some counts and stats to be reported to the user.
            par_files_found   = 0
            valid_par_files   = 0
            other_files_found = 0
            invalid_par_files = 0

            # Stores ParFile objects, constructed from valid paths to par files.
            pars = []

            # Loop through the specified directory
            for root, subFolders, file_names in os.walk(self.par_dir):

                # for each file
                for filename in file_names:
                    path = os.path.join(root, filename)  # Gets full path to the par.

                    # Try and create a ParFile object.
                    par_file = ParFile()

                    if ".par" in path:
                        par_files_found += 1

                        # Use the ParFile object to verify the object...
                        if par_file.read(path, False):
                            valid_par_files += 1
                            pars.append(par_file)
                        else:
                            invalid_par_files += 1
                    else:
                        other_files_found += 1

            # Some reporting...
            print("\tNon-par Files found: "      + str(other_files_found))
            print("\tPar Files found: "          + str(par_files_found))
            print("\tValid Par Files found: "    + str(valid_par_files))
            print("\tInvalid Par Files found: "  + str(invalid_par_files))
            print("\tPar file objects created: " + str(len(pars)))

            # If we have 1 or more valid ParFile objects...
            if len(pars) > 0:

                # We can proceed to the generation step using the par files found.
                print("\n\t**************************")
                print("\t|  Build Tempo2 Commands |")
                print("\t**************************")

                # Stores the Tempo2 commands to be executed, which generate the .dat files.
                commands = []

                # Maintain some counts and stats to be reported to the user.
                generation_errors          = 0
                generation_successes       = 0
                predictors_copied          = 0
                predictors_failing_to_copy = 0

                start = datetime.datetime.now()  # Used to measure feature generation time.

                # Create a log file path, to record what happens. Useful for debugging this step.
                log_file_path = self.output_dir + "/GenPredFiles_" + str(start).replace(" ", "_") + ".log"
                print("\tCreated a log file at: " + str(log_file_path) + "\n")

                # Clear and prepare log...
                GeneratePredictorFiles.clear_file(log_file_path)
                GeneratePredictorFiles.append_to_file(log_file_path, "GeneratePredictorFiles.py v2.0 LOG\n")

                # For each par file object we've found so far...
                for par_file in pars:

                    # Get the full path to the .par file.
                    par_file_path = par_file.fpth

                    # Bit of defensive programming here, these *should* exist.
                    if Common.file_exists(par_file_path):

                        # Constrcut the Tempo2 command here.
                        command = "tempo2 -f " + par_file_path + " -pred \"" + self.telescope + " " +\
                                  str(self.mjd1) + " " + str(self.mjd2) + " " + str(self.f1) + " " + str(self.f2) + \
                                  " " + str(self.tcoeff) + " " + str(self.fcoeff) + " " + str(self.obs_length) + "\""

                        # Add it to the list of commands.
                        commands.append(command)

                        # Some log file updates, just in case something does go wrong.
                        GeneratePredictorFiles.append_to_file(log_file_path, "\nCreated Command:\n")
                        GeneratePredictorFiles.append_to_file(log_file_path, command + "\n")

                        # Now try to create a PrefFile Object.
                        pred = PredFile()

                        # Build the file name we want this .dat (predictor) file to have.
                        output_file_name = pred.create_valid_file_name(par_file.name, par_file.dm, par_file.period,
                                                                       self.obs_length, self.f1, self.f2, self.tcoeff,
                                                                       self.fcoeff, par_file.accel)
                        if self.verbose:
                            print("\tOutput file path: " + str(output_file_name))

                        GeneratePredictorFiles.append_to_file(log_file_path, "Created predictor file name:")
                        GeneratePredictorFiles.append_to_file(log_file_path, output_file_name + "\n")

                        # Now try to execute the tempo2 command...
                        #
                        process = subprocess.Popen(command, shell=True)
                        process.wait()

                        # For debugging on local machine
                        #Common.create_file("t2pred.dat")

                        # If the expected output file exists... Note that tempo2 always writes an output
                        # file called t2pred.dat, which is why this is hard coded here.
                        if os.path.exists("t2pred.dat"):

                            generation_successes += 1

                            # Now we want to copy the file to the desired output location,
                            # i.e. with the .dat filename we created above.
                            out_path = self.output_dir + "/" + output_file_name

                            # This will clear the output file if it exists, otherwise it will create it.
                            GeneratePredictorFiles.clear_file(out_path)

                            # Now do the copy...
                            copyfile("t2pred.dat", out_path)

                            # Check the file exists.
                            if os.path.exists(output_file_name):
                                # The file was copied successfully.
                                predictors_copied += 1
                            else:
                                predictors_failing_to_copy += 1

                        else:
                            # The expected t2pred.dat file does not exist - tempo2 must have
                            # encountered some problem. Tell the user...
                            print("\tError generating predictor file for par: " + str(par_file_path))

                            generation_errors += 1

                # Finally get the time that the procedure finished.
                end = datetime.datetime.now()

                duration = end - start

                print("\n\tPredictor generation errors:\t\t\t"     + str(generation_errors))
                print("\tPredictor files generated:\t\t\t\t"       + str(generation_successes))
                print("\tPredictor files unsuccessfully copied:\t" + str(predictors_failing_to_copy))
                print("\tPredictor files successfully copied:\t"   + str(predictors_copied) + "\n\n")
                print("\tExecution time:\t\t" + str(end - start)   + " (hh:mm:ss)")

                # Average execution time per test vector...
                avg_execution_time_secs = (duration.total_seconds()) / float(generation_successes)
                print("\tAvg. per vector:\t" + str(avg_execution_time_secs) + " seconds")

            else:
                print("\tNo valid par files found, cannot proceed.")

        else:
            print("\n\t**************************")
            print("\t|   Parameters Invalid  |")
            print("\t**************************")
            print("\tCannot generate predictor files, exiting.")


        print("\n\tDone.")
        print("\n**************************************************************************\n")

    # ******************************************************************************************

    # ******************************
    #
    # COMMAND LINE PROCESSING CODE
    #
    # ******************************

    def check_parameters(self, args):
        """
        Checks the parameters provided by the user.

        Parameters
        ----------
        self : object
            The object pointer.

        args : []
            The arguments. These are ordered as follows:
            args[0]  = verbose flag
            args[1]  = Par file directory (string)
            args[2]  = Predictor output directory (string)
            args[3]  = Observation length in seconds (int)
            args[4]  = first Channel frequency (float)
            args[5]  = last Channel frequency (float)
            args[6]  = number of time coefficients (int)
            args[7]  = number of frequency coefficients (int)
            args[8]  = MJD start (float)
            args[9] = MJD end (float)
            args[10] = telescope (string)

        Returns
        -------
        True if the parameters are valid, else False.

        """

        print("\n\t**************************")
        print("\t|  Checking Parameters   |")
        print("\t**************************")

        # There are eight command line parameters - these must be checked
        # to ensure the user doesn't do anything crazy. We check each parameter
        # in turn, in different ways including,
        #
        # 1. Type checking
        # 2. Formatting checks
        # 3. Boundary condition checks
        #
        # This means there are a lot of checks to do...

        outcome = True

        # Check the types are as expected.
        outcome = GeneratePredictorFiles.check_parameter_types(args)

        if not outcome:
            print("\tOne or more parameters are not of the expected type.")
            return False

        outcome = GeneratePredictorFiles.check_parameter_values(args)

        if not outcome:
            print("\tOne or more parameter values do not adhere to boundary/range conditions.")
            return False
        else:
            # Lets check the directory paths provided by the user...

            # Check the par file directory is valid.
            if len(args[1]) > 0:
                outcome = GeneratePredictorFiles.check_dir_exists_or_create(args[1])

                if not outcome:
                    print("\tPar file directory does not exist.")
                    return False

            # Check the predictor output directory is valid.
            if len(args[2]) > 0:
                outcome = GeneratePredictorFiles.check_dir_exists_or_create(args[2])

                if not outcome:
                    print("\tPredictor output directory does not exist/could not be created.")
                    return False

        print("\n\tParameter check complete.")

        return True

    # ******************************************************************************************

    @staticmethod
    def check_parameter_types(args, testing=False):
        """
        Checks the parameters provided by the user are of the correct type.

        Parameters
        ----------

        args : []
            The arguments. These are ordered as follows:
            args[0]  = verbose flag
            args[1]  = Par file directory (string)
            args[2]  = Predictor output directory (string)
            args[3]  = Observation length in seconds (int)
            args[4]  = first Channel frequency (float)
            args[5]  = last Channel frequency (float)
            args[6]  = number of time coefficients (int)
            args[7]  = number of frequency coefficients (int)
            args[8]  = MJD start (float)
            args[9] = MJD end (float)
            args[10] = telescope (string)

        testing : boolean
                A flag that when true, suppresses output during testing.

        Returns
        -------
        True if the parameters are valid, else False.

        """

        outcome = True

        # Verbose flag
        if type(args[0]) != bool:
            if not testing:
                print("\tVerbose parameter not the correct type (" + str(type(args[0])) + ").")
            outcome = False

        # Par file directory
        if type(args[1]) != str:
            if not testing:
                print("\tPar file directory parameter not a string (" + str(type(args[1])) + ").")
            outcome = False

        # Output directory
        if type(args[2]) != str:
            if not testing:
                print("\tOutput directory parameter not a string (" + str(type(args[2])) + ").")
            outcome = False

        # Observation length
        if type(args[3]) != int:
            if not testing:
                print("\tObservation length parameter not an int (" + str(type(args[3])) + ").")
            outcome = False

        # First channel
        if type(args[4]) != float:
            if not testing:
                print("\tFirst channel (F1) parameter not a float (" + str(type(args[4])) + ").")
            outcome = False

        # Last channel
        if type(args[5]) != float:
            if not testing:
                print("\tLast channel (F2) parameter not a float (" + str(type(args[5])) + ").")
            outcome = False

        # Number of time coefficients
        if type(args[6]) != int:
            if not testing:
                print("\tNumber of time coefficients parameter not an int (" + str(type(args[6])) + ").")
            outcome = False

        # Number of frequency coefficients
        if type(args[7]) != int:
            if not testing:
                print("\tNumber of frequency coefficients parameter not an int (" + str(type(args[7])) + ").")
            outcome = False

        # MJD Start
        if type(args[8]) != float:
            if not testing:
                print("\tMJD Start parameter not a float (" + str(type(args[9])) + ").")
            outcome = False

        # MJD End
        if type(args[9]) != float:
            if not testing:
                print("\tMJD End parameter not a float (" + str(type(args[10])) + ").")
            outcome = False

        # Telescope
        if type(args[10]) != str:
            if not testing:
                print("\tTelescope parameter not a string (" + str(type(args[11])) + ").")
            outcome = False

        return outcome

    # ******************************************************************************************

    @staticmethod
    def check_parameter_values(args, testing=False):
        """
        Checks the parameter values provided by the user do not violate boundary
        or range conditions.

        Parameters
        ----------

        args : []
            The arguments. These are ordered as follows:
            args[0]  = verbose flag
            args[1]  = Par file directory (string)
            args[2]  = Predictor output directory (string)
            args[3]  = Observation length in seconds (int)
            args[4]  = first Channel frequency (float)
            args[5]  = last Channel frequency (float)
            args[6]  = number of time coefficients (int)
            args[7]  = number of frequency coefficients (int)
            args[8]  = MJD start (float)
            args[9]  = MJD end (float)
            args[10] = telescope (string)

        testing : boolean
                A flag that when true, suppresses output during testing.

        Returns
        -------
        True if the parameters are valid, else False.

        """

        outcome = True

        # observation length
        if args[3] <= 0:
            if args[3] <= 100:
                print("\tWARNING: short observation lengths (<600 seconds) cause Tempo2 to hang .")
                print("\tRECOMMENDATION: Set the observation length t0 at least 100 seconds.")

            if not testing:
                print("\tObservation length too short (must be > than 0, ideally greater than 100) .")
            outcome = False

        # First channel
        if args[4] <= 0.0:
            if not testing:
                print("\tFirst channel (F1) parameter must be > 0.")
            outcome = False

        # First channel
        if args[5] <= 0.0:
            if not testing:
                print("\tLast channel (F2) parameter must be > 0.")
            outcome = False

        # Channel Start vs End check
        if args[5] <= args[4]:
            if not testing:
                print("\tF2 parameter must be less than F1 parameter.")
            outcome = False

        # Time coefficients
        if args[6] <= 0:
            if not testing:
                print("\tTime coefficient parameter must be > 0.")
            outcome = False

        # Frequency coefficients
        if args[7] <= 0:
            if not testing:
                print("\tFrequency coefficient parameter must be > 0.")
            outcome = False

        # MJD Start
        if args[8] <= 0:
            if not testing:
                print("\tMJD Start value must be > 0. ")
            outcome = False

        # MJD End
        if args[9] <= 0:
            if not testing:
                print("\tMJD End value must be > 0. ")
            outcome = False

        # MJD Start vs MJD End check
        if args[9] <= args[8]:
            if not testing:
                print("\tMJD Start must be less than MJD End.")
            outcome = False

        return outcome

    # ******************************************************************************************

    @staticmethod
    def check_dir_exists_or_create(out_dir):
        """
        Checks if a directory exists. If it doesn't, we try to create it.
        If this method returns false, this operation failed. Otherwise
        True is returned.

        Parameters
        ----------
        :param out_dir: the directory to check for/create as appropriate.

        Returns
        -------
        True if the directory exists/was created, else false.
        """

        # The user should have supplied an output directory path. But, it may
        # not be valid. to check we first, try to create the directory. If the
        # create call fails, the directory path is invalid.
        if not os.path.exists(out_dir):
            print("\n\tOutput directory does not exist, trying to create...")
            try:
                os.makedirs(out_dir)
            except OSError:
                print("\n\tException encountered trying to create output directory.")
                return False
        else:
            return True  # Directory must exist.

        # If the directory creation call above did not fail, the output directory
        # should now exist. Check that this is the case...
        if not os.path.isdir(out_dir):
            print("\n\tOutput directory could not be created.")
            return False
        else:
            print("\n\tOutput directory exists.")
            return True

    # ******************************************************************************************

    # ******************************
    #
    # FILE HANDLING CODE
    #
    # ******************************

    @staticmethod
    def append_to_file(path, text):
        """Appends the provided text to the file at the specified path.

        Parameters
        ----------
        path : str
            The full path to the file to write to.
        text : str
            The text to write to the output file.

        Examples
        --------
        >>> append_to_file("/Users/rob/test.txt","This is my text")

        which will append the text "This is my text" to the file.
        """

        try:
            destination_file = open(path, 'a')
            destination_file.write(str(text))
            destination_file.close()
            return True
        except IOError:
            return False

    # ******************************************************************************************

    @staticmethod
    def clear_file(path):
        """
        Clears the contents of the file at the specified path.

        Parameters
        ----------
        path : str
            The full path to the file to clear.

        Examples
        --------
        >>> clear_file("/Users/rob/test.txt")

        which will clear all text in the file.
        """
        open(path, 'w').close()

    # ******************************************************************************************

if __name__ == '__main__':
    GeneratePredictorFiles().main()
