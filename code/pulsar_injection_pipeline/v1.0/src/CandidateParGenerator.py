## @package PARS
# A module used to create Tempo2 compatible par files.
#
# Author: Rob Lyon
# Email : robert.lyon@manchester.ac.uk
# web   : www.scienceguyrob.com

# Start normal non-doxygen docstring...
"""
    **************************************************************************
    |                                                                        |
    |              Candidate Par file Generator Version 1.0                  |
    |                                                                        |
    **************************************************************************
    | Description:                                                           |
    |                                                                        |
    | Generates fake pulsar parameters, including period, S/N,               |
    | DM, pulse width, duty cycle, and S/N. These parameters are written to  |
    | an output file in CSV format (one set of parameters per line) for      |
    | input into other tools. The distributions used to create the fake      |
    | parameters can be controlled (see options below).                      |
    |                                                                        |
    | This script also generates .PAR files for entries in the ATNF pulsar   |
    | catalog, and creates par files that represent fake pulsars using the   |
    | parameters generated by this script. The script stores the par files   |
    | in a user specified directory. Each par file is either saved using the |
    | pulsar name as the filename, followed by the .par suffix, e.g.,        |
    |                                                                        |
    |  J1937+2950.par                                                        |
    |                                                                        |
    | or for fake pulsar examples,                                           |
    |                                                                        |
    | FakePulsar_<number>_<DM>_<Period (ms)>_<SNR>.par                       |
    |                                                                        |
    | Running this code will overwrite existing par files for both pulsar    |
    | and non-pulsar examples if automatically generated file names match    |
    | the names of existing files.                                           |
    |                                                                        |
    | The code is compatible with python version 2.7. It requires scipy      |
    | version 0.15 or later to function. Numpy libraries and matplotlib are  |
    | also required.                                                         |
    |                                                                        |
    **************************************************************************
    | Author: Rob Lyon                                                       |
    | Email : robert.lyon@manchester.ac.uk                                   |
    | web   : www.scienceguyrob.com                                          |
    **************************************************************************
    | Required Command Line Arguments:                                       |
    |                                                                        |
    | -d (string) full path to the directory to store par files in.          |
    |                                                                        |
    | -w (string) full path to a the output file to create. The output       |
    |             format is as follows:                                      |
    |                                                                        |
    |             Period,DM,pulse width,duty cycle                           |
    |                                                                        |
    **************************************************************************
    | Optional Command Line Arguments:                                       |
    |                                                                        |
    | -v (boolean) verbose debugging flag.                                   |
    |                                                                        |
    | --atnf (string) full path to a parsed ATNF pulsar catalog database     |
    |             file. The file should contain data describing individual   |
    |             known sources from the catalog as follows:                 |
    |                                                                        |
    |             Period (s),Frequency (Hz),DM,W10 (ms),W50 (ms)             |
    |             0.69374767047,1.44144628165,12.0,195,82                    |
    |             0.315873190853,3.165827392,0,0,0                           |
    |             ...                                                        |
    |                                                                        |
    | -s (int)    the number of output samples to generate (1000 by default).|
    |                                                                        |
    | -m (string) full path to an ARFF parsed ML training set file. The file |
    |             should contain data describing individual training set     |
    |             entries as follows:                                        |
    |                                                                        |
    |             Period (ms),S/N,DM,Pulse Width (ms),Duty Cycle,SNR         |
    |             6.80380912,8.926689,240.202744,0.492188,0.0723400,14.3     |
    |             232.8519815,6.368472,599.795997,0.101562,0.000436,7.8      |
    |             ...                                                        |
    |                                                                        |
    |             This data is used to generate fake pulsar data, instead of |
    |             using random distributions specified using the --snr, --p0,|
    |             or --dm flags.                                             |
    |                                                                        |
    |             Note: the script ATNFDataExtractor.py can be used to       |
    |                   generate files in the desired format.                |
    |                                                                        |
    | --seed (int) the random seed (1 by default).                           |
    |                                                                        |
    | --snr (string) the data distribution to use to model fake pulsar S/Ns. |
    |                Available distributions are listed at:                  |
    |                                                                        |
    |         http://docs.scipy.org/doc/numpy/reference/routines.random.html |
    |                                                                        |
    |               For example: expon, norm, rayleigh are all valid. The    |
    |               normal model is used by default. Acceptable values are   |
    |               shown below.                                             |
    |                                                                        |
    |               key         params                  Name                 |
    |               beta        a, b, loc, scale        Beta dist.           |
    |               expon       loc, scale              exponential dist.    |
    |               gamma       shape, loc, scale       Gamma dist.          |
    |               logistic    loc, scale              logistic dist.       |
    |               lognorm     s, mean, sigma          log-normal dist.     |
    |               norm        loc, scale              normal dist.         |
    |               truncnorm   min, max,loc, scale     normal dist.         |
    |               rayleigh    loc, scale              Rayleigh dist.       |
    |               uniform     min, max                uniform dist.        |
    |                                                                        |
    | --snrparams (string) the parameters of the S/N distribution. These must|
    |                     be provided concatenated together in a single      |
    |                     string separated by a colon (:), e.g.              |
    |                                                                        |
    |                    1:6                                                 |
    |                                                                        |
    |                    which could represent the location and scale of a   |
    |                    user specified distribution. The values can differ  |
    |                    depending on the distribution used, and it is up to |
    |                    the user to supply sensible values (defaults which  |
    |                    assume a normal distribution as described above     |
    |                    are set to 10 and 5).                               |
    |                                                                        |
    | --p0 (string) the data distribution to use for modelling fake pulsar   |
    |               periods. Available distributions are listed above. The   |
    |               normal model is used by default.                         |
    |                                                                        |
    | --p0params (string) the parameters of the period distribution. These   |
    |                     must be provided concatenated together in a single |
    |                     string separated by a colon (:). Defaults set to   |
    |                     10 and 5 for the normal distribution.              |
    |                                                                        |
    | --dm (string) the data distribution to use for modelling fake pulsar   |
    |               DMs. Available distributions are listed above. The       |
    |               normal model is used by default.                         |
    |                                                                        |
    | --dmparams (string) the parameters of the DM distribution. These must  |
    |                     be provided concatenated together in a single      |
    |                     string separated by a colon (:). Defaults set to   |
    |                     10 and 5 for the normal distribution.              |
    |                                                                        |
    | --duty (string) the data distribution to use for modelling fake pulsar |
    |               duty cycles. Available distributions are listed above.   |
    |               the normal model is used by default.                     |
    |                                                                        |
    | --dutyparams (string) the parameters of the duty cycle distribution.   |
    |                     These must be provided concatenated together in a  |
    |                     single string separated by a colon (:). Defaults   |
    |                     set to 10 and 5 for the normal distribution.       |
    |                                                                        |
    | --pepoch     (string) the period epoch value to use in the par files.  |
    |              By default the value 56000.0 is used.                     |
    |                                                                        |
    | --tzrmjd     (string) the TZRMJD value to use in the par files.        |
    |              By default the value 56000.0 is used.                     |
    |                                                                        |
    | --tzrfreq    (string) the TZRFREQ value to use in the par files.       |
    |              By default the value 1000.0 is used.                      |
    |                                                                        |
    | --units      (string) the UNITS value to use in the par files.         |
    |              By default the value TDB is used.                         |
    |                                                                        |
    **************************************************************************
    | License:                                                               |
    |                                                                        |
    | Code made available under the GPLv3 (GNU General Public License), that |
    | allows you to copy, modify and redistribute the code as you see fit    |
    | (http://www.gnu.org/copyleft/gpl.html). Though a mention to the        |
    | original author using the citation above in derivative works, would be |
    | very much appreciated.                                                 |
    **************************************************************************
"""

# Command Line processing Imports:
from optparse import OptionParser

import os
import sys

# Numpy Imports:
from numpy import ceil
from numpy import percentile
from numpy import mean
from numpy import random
from numpy import median
from numpy import count_nonzero

# Scipy Imports:
from scipy import std
from scipy import stats
from scipy import arange


# Other imports
import matplotlib.pyplot as plt

# ******************************
#
# CLASS DEFINITION
#
# ******************************

## Candidate Par file Generator Version 1.0
#
# Description:
#
# Generates fake pulsar parameters, including period, S/N,
# DM, pulse width, duty cycle, and S/N. These parameters are written to
# an output file in CSV format (one set of parameters per line) for
# input into other tools. The distributions used to create the fake
# parameters can be controlled (see options below).
#
# This script also generates .PAR files for entries in the ATNF pulsar
# catalog, and creates par files that represent fake pulsars using the
# parameters generated by this script. The script stores the par files
# in a user specified directory. Each par file is either saved using the
# pulsar name as the filename, followed by the .par suffix, e.g.,
#
#  J1937+2950.par
#
# or for fake pulsar examples,
#
# FakePulsar_<number>_<DM>_<Period (ms)>_<SNR>.par
#
# Running this code will overwrite existing par files for both pulsar
# and non-pulsar examples if automatically generated file names match
# the names of existing files.
#
# The code is compatible with python version 2.7. It requires scipy
# version 0.15 or later to function. Numpy libraries and matplotlib are
# also required.
#
#
# Author: Rob Lyon
# Email : robert.lyon@manchester.ac.uk
# web   : www.scienceguyrob.com
#
# Required Command Line Arguments:
#
# -d (string) full path to the directory to store par files in.
#
# -w (string) full path to a the output file to create. The output
#             format is as follows:
#
#             Period,DM,pulse width,duty cycle
#
#
# Optional Command Line Arguments:
#
# -v (boolean) verbose debugging flag.
#
# --atnf (string) full path to a parsed ATNF pulsar catalog database
#             file. The file should contain data describing individual
#             known sources from the catalog as follows:
#
#             Period (s),Frequency (Hz),DM,W10 (ms),W50 (ms)
#             0.69374767047,1.44144628165,12.0,195,82
#             0.315873190853,3.165827392,0,0,0
#             ...
#
# -s (int)    the number of output samples to generate (1000 by default).
#
# -m (string) full path to an ARFF parsed ML training set file. The file
#             should contain data describing individual training set
#             entries as follows:
#
#             Period (ms),S/N,DM,Pulse Width (ms),Duty Cycle,SNR
#             6.80380912,8.926689,240.202744,0.492188,0.0723400,14.3
#             232.8519815,6.368472,599.795997,0.101562,0.000436,7.8
#             ...
#
#             This data is used to generate fake pulsar data, instead of
#             using random distributions specified using the --snr, --p0,
#             or --dm flags.
#
# --seed (int) the random seed (1 by default).
#
# --snr (string) the data distribution to use to model fake pulsar S/Ns.
#                Available distributions are listed at:
#
#         http://docs.scipy.org/doc/numpy/reference/routines.random.html
#
#               For example: expon, norm, rayleigh are all valid. The
#               normal model is used by default. Acceptable values are
#               shown below.
#
#               key         params                  Name
#               beta        a, b, loc, scale        Beta dist.
#               expon       loc, scale              exponential dist.
#               gamma       shape, loc, scale       Gamma dist.
#               logistic    loc, scale              logistic dist.
#               lognorm     s, mean, sigma          log-normal dist.
#               norm        loc, scale              normal dist.
#               truncnorm   min, max,loc, scale     normal dist.
#               rayleigh    loc, scale              Rayleigh dist.
#               uniform     min, max                uniform dist.
#
# --snrparams (string) the parameters of the S/N distribution. These must
#                     be provided concatenated together in a single
#                     string separated by a colon (:), e.g.
#
#                    1:6
#
#                    which could represent the location and scale of a
#                    user specified distribution. The values can differ
#                    depending on the distribution used, and it is up to
#                    the user to supply sensible values (defaults which
#                    assume a normal distribution as described above
#                    are set to 10 and 5).
#
# --p0 (string) the data distribution to use for modelling fake pulsar
#               periods. Available distributions are listed above. The
#               normal model is used by default.
#
# --p0params (string) the parameters of the period distribution. These
#                     must be provided concatenated together in a single
#                     string separated by a colon (:). Defaults set to
#                     10 and 5 for the normal distribution.
#
# --dm (string) the data distribution to use for modelling fake pulsar
#               DMs. Available distributions are listed above. The
#               normal model is used by default.
#
# --dmparams (string) the parameters of the DM distribution. These must
#                     be provided concatenated together in a single
#                     string separated by a colon (:). Defaults set to
#                     10 and 5 for the normal distribution.
#
# --duty (string) the data distribution to use for modelling fake pulsar
#               duty cycles. Available distributions are listed above.
#               the normal model is used by default.
#
# --dutyparams (string) the parameters of the duty cycle distribution.
#                     These must be provided concatenated together in a
#                     single string separated by a colon (:). Defaults
#                     set to 10 and 5 for the normal distribution.
#
# --pepoch     (string) the period epoch value to use in the par files.
#              By default the value 56000.0 is used.
#
# --tzrmjd     (string) the TZRMJD value to use in the par files.
#              By default the value 56000.0 is used.
#
# --tzrfreq    (string) the TZRFREQ value to use in the par files.
#              By default the value 1000.0 is used.
#
# --units      (string) the UNITS value to use in the par files.
#              By default the value TDB is used.
#
#
# License:
#
# Code made available under the GPLv3 (GNU General Public License), that
# allows you to copy, modify and redistribute the code as you see fit
# (http://www.gnu.org/copyleft/gpl.html). Though a mention to the
# original author using the citation above in derivative works, would be
# very much appreciated.
class CandidateParGenerator:
    """
    Description:

    Generates fake pulsar parameters, including period, S/N,
    DM, pulse width, duty cycle, and S/N. These parameters are written to
    an output file in CSV format (one set of parameters per line) for
    input into other tools. The distributions used to create the fake
    parameters can be controlled (see options below).

    This script also generates .PAR files for entries in the ATNF pulsar
    catalog, and creates par files that represent fake pulsars using the
    parameters generated by this script. The script stores the par files
    in a user specified directory. Each par file is either saved using the
    pulsar name as the filename, followed by the .par suffix, e.g.,

     J1937+2950.par

    or for fake pulsar examples,

    FakePulsar_<number>_<Period (s)>_<DM>_<SNR>.par

    Running this code will overwrite existing par files for both pulsar
    and non-pulsar examples if automatically generated file names match
    the names of existing files.

    The code is compatible with python version 2.7. It requires scipy
    version 0.15 or later to function. Numpy libraries and matplotlib are
    also required.
    """

    # ******************************
    #
    # MAIN METHOD AND ENTRY POINT.
    #
    # ******************************

    ## The main method for the class.
    # Main entry point for the Application. Processes command line
    # input and begins automating the creation of par files.
    #
    #  @param self The object pointer.
    #  @param argv The unused arguments.
    def main(self, argv=None):
        """Main method.

        Main entry point for the Application. Processes command line
        input and begins automating the the creation of par files.

        Parameters
        ----------
        argv : str
            The unused arguments.

        """

        # ****************************************
        #         Execution information
        # ****************************************

        print(__doc__)

        # ****************************************
        #    Command line argument processing
        # ****************************************

        # Python 2.4 argument processing.
        parser = OptionParser()

        # REQUIRED ARGUMENTS
        parser.add_option("-m", action="store", dest="arffPath",
                          help='Path to a ARFF parsed file.', default="")

        parser.add_option("-d", action="store", dest="outputDir",
                          help='Path to a valid output directory.', default="")

        parser.add_option("-w", action="store", dest="outputPath",
                          help='Path to write outputs to.', default="")

        # OPTIONAL ARGUMENTS
        parser.add_option("--atnf", action="store", dest="atnfPath",
                          help='Path to a pulsar catalog parsed file.', default="")

        parser.add_option("-v", action="store_true", dest="verbose",
                          help='Verbose debugging flag (optional).', default=False)

        parser.add_option("-s", type="int", dest="samples",
                          help='The total number of samples to generate (optional).', default=1000)

        parser.add_option("--seed", type="int", dest="seed",
                          help='The seed value for random number generation (optional).', default=1)

        parser.add_option("--snr", action="store", dest="snrDist",
                          help='The distribution to use to model fake pulsar S/Ns', default="norm")

        parser.add_option("--snrparams", action="store", dest="snrDistParams",
                          help='Parameters used to initialise the S/N distribution', default="10:5")

        parser.add_option("--p0", action="store", dest="p0Dist",
                          help='The distribution to use to model fake pulsar periods', default="norm")

        parser.add_option("--p0params", action="store", dest="p0DistParams",
                          help='Parameters used to initialise the period distribution', default="10:5")

        parser.add_option("--dm", action="store", dest="dmDist",
                          help='The distribution to use to model fake pulsar DMs', default="norm")

        parser.add_option("--dmparams", action="store", dest="dmDistParams",
                          help='Parameters used to initialise the DM distribution', default="10:5")

        parser.add_option("--duty", action="store", dest="dutyDist",
                          help='The distribution to use to model fake pulsar duty cycles', default="norm")

        parser.add_option("--dutyparams", action="store", dest="dutyDistParams",
                          help='Parameters used to initialise the duty cycle distribution',default="10:5")

        parser.add_option("--pepoch", action="store", dest="pepoch",
                          help='The period epoch to use in the par files', default="56000.0")

        parser.add_option("--tzrmjd", action="store", dest="tzrmjd",
                          help='The tzrmjd value to use in the par files', default="56000.0")

        parser.add_option("--tzrfreq", action="store", dest="tzrfreq",
                          help='The tzrfreq value to use in the par files', default="1000.0")

        parser.add_option("--units", action="store", dest="units",
                          help='The units to use in the par files', default="TDB")

        (args, options) = parser.parse_args()

        # Update variables with command line parameters.
        self.verbose        = args.verbose
        self.atnfParsedPath = args.atnfPath
        self.arffParsedPath = args.arffPath
        self.outputPath     = args.outputPath
        self.outputDir      = args.outputDir
        self.samples        = args.samples
        self.seed           = args.seed

        self.pepoch         = args.pepoch
        self.tzrmjd         = args.tzrmjd
        self.tzrfreq        = args.tzrfreq
        self.units          = args.units

        # Variables for managing distributions
        self.distributions  = ["beta"   , "binom", "expon"    , "gamma"   , "logistic",
                               "lognorm", "norm" , "truncnorm", "rayleigh", "uniform"]
        self.params         = [4, 3, 2, 3, 2, 3, 2, 4, 2, 2]
        self.distDict       = dict(zip(self.distributions, self.params))


        self.snrDist  = args.snrDist
        self.p0Dist   = args.p0Dist
        self.dmDist   = args.dmDist
        self.dutyDist = args.dutyDist

        self.p0DistParams   = []
        self.snrDistParams  = []
        self.dmDistParams   = []
        self.dutyDistParams = []

        # Assume to begin with that the user will supply parameters for fake candidate
        # auto generation.
        self.autoGenerate = True
        self.parseATNFFile = False

        try:
            # Parse distribution parameters...
            self.p0DistParams   = map(float, args.p0DistParams.split(":"))
            self.snrDistParams  = map(float, args.snrDistParams.split(":"))
            self.dmDistParams   = map(float, args.dmDistParams.split(":"))
            self.dutyDistParams = map(float, args.dutyDistParams.split(":"))
        except Exception as e:  # Catch *all* exceptions.
            print("\tError parsing distribution parameters (must be numeric only.)\n\t" + str(sys.exc_info()[0]))
            print("\tExiting...")
            sys.exit()

        # ****************************************
        #   Print command line arguments & Run
        # ****************************************

        print("\n\t**************************")
        print("\t| Command Line Arguments |")
        print("\t**************************")
        print("\tDebug: "                           + str(self.verbose))
        print("\tParsed Pulsar catalog file path: " + str(self.atnfParsedPath))
        print("\tParsed ARFF file path: "           + str(self.arffParsedPath))
        print("\tOutput file path: "                + str(self.outputPath))
        print("\tOutput file dir: "                 + str(self.outputDir))

        print("\tPepoch value for par: "  + str(self.pepoch))
        print("\tTZRMJD value for par: "  + str(self.tzrmjd))
        print("\tTZRFREQ value for par: " + str(self.tzrfreq))
        print("\tUNITS value for par: "   + str(self.units))


        print("\tS/N modelling dist: "         + str(self.snrDist))
        print("\tS/N dist parameters: "        + str(self.snrDistParams))
        print("\tPeriod modelling dist: "      + str(self.p0Dist))
        print("\tPeriod dist parameters: "     + str(self.p0DistParams))
        print("\tDM modelling dist: "          + str(self.dmDist))
        print("\tDM dist parameters: "         + str(self.dmDistParams))
        print("\tDuty cycle modelling dist: "  + str(self.dutyDist))
        print("\tDuty cycle dist parameters: " + str(self.dutyDistParams))
        print("\tRandom seed: "                + str(self.seed))
        print("\tAuto generate fake pulsars from distributions: " + str(self.autoGenerate))

        # Check arguments for validity...
        if os.path.isfile(self.atnfParsedPath):
            self.parseATNFFile = True

        if os.path.isfile(self.arffParsedPath):
            print("\n\tValid ARFF file supplied, fake pulsars will be generated from this data file.")
            self.autoGenerate = False

        # First check user has supplied a par file output directory path ...
        if not self.outputDir:
            print("\n\tYou must supply a valid output directory file via the -d flag.")
            print("\tExiting...")
            sys.exit()

        # Now the user may have supplied an output directory path, but it may
        # not be valid. So first, try to create the directory, if it doesn't
        # already exist. If the create fails, the directory path must be invalid,
        # so exit the application.
        if os.path.exists(self.outputDir) is False:
            try:
                os.makedirs(self.outputDir)
            except OSError as exception:
                print("\n\tException encountered trying to create par file output directory - Exiting!")
                print("\tExiting...")
                sys.exit()

        # If the directory creation call above did not fail, the output directory
        # should now exist. Check that this is the case...
        if os.path.isdir(self.outputDir) is False:
            print("\n\tPar file output directory invalid - Exiting!")
            print("\tExiting...")
            sys.exit()
        else:
            self.pulsarParFileDir = self.outputDir + "/Pulsar"
            self.fakePulsarParFileDir = self.outputDir + "/FakePulsar"

            # Create new output directories
            if os.path.exists(self.pulsarParFileDir) is False:
                os.makedirs(self.pulsarParFileDir)

            if os.path.exists(self.fakePulsarParFileDir) is False:
                os.makedirs(self.fakePulsarParFileDir)

        # Check the buffer value supplied by the user...
        if self.seed < 0:
            print("\n\tSupplied seed value invalid - Exiting!")
            print("\tExiting...")
            sys.exit()

        # Now check supplied distribution parameters
        if self.snrDist not in self.distributions:
            print("\tInvalid S/N distribution supplied: " + str(self.snrDist))
            print("\tExiting...")
            sys.exit()

        if self.p0Dist not in self.distributions:
            print("\tInvalid period distribution supplied: " + str(self.p0Dist))
            print("\tExiting...")
            sys.exit()

        if self.dmDist not in self.distributions:
            print("\tInvalid DM distribution supplied: " + str(self.dmDist))
            print("\tExiting...")
            sys.exit()

        if self.dutyDist not in self.distributions:
            print("\tInvalid duty cycle distribution supplied: " + str(self.dutyDist))
            print("\tExiting...")
            sys.exit()

        canProceed = True
        if self.autoGenerate:

            for key, value in self.distDict.iteritems():

                if self.snrDist == key:
                    if len(self.snrDistParams) != int(value):
                        print("\tIncorrect number of parameters supplied for the " + str(key) + " S/N distribution.")
                        print("\tRequired "  + str(value) + " but received " + str(len(self.snrDistParams)))
                        canProceed = False

                if self.p0Dist == key:
                    if len(self.p0DistParams) != int(value):
                        print("\tIncorrect number of parameters supplied for the " + str(key) + " period distribution.")
                        print("\tRequired " + str(value) + " but received " + str(len(self.p0DistParams)))
                        canProceed = False

                if self.dmDist == key:
                    if len(self.dmDistParams) != int(value):
                        print("\tIncorrect number of parameters supplied for the " + str(key) + " DM distribution.")
                        print("\tRequired " + str(value) + " but received " + str(len(self.dmDistParams)))
                        canProceed = False

        # Check supplied distribution parameters.
        if canProceed is False:
            print("\tCould not proceed to fake pulsar parameter generation!")
            print("\tExiting...")
            sys.exit()

        # Now seed random number generator
        random.seed(seed=self.seed)

        # Now we know the input files exist...

        # Clear the output file of text.
        try:
            self.clearFile(self.outputPath)
        except IOError:
            print("\tCould not create/access the output file - is the path valid?")
            print("\tExiting...")
            sys.exit()


        # Write a header to the output file...
        self.appendToFile(self.outputPath, "Period (s),DM,Pulse Width (s),Duty Cycle,SNR\n")

        # ****************************************
        #
        #
        #
        #         File parsing section
        #
        #
        #
        # ****************************************

        # ****************************************
        #            Parse ATNF file
        # ****************************************

        # Variables we are looking for in the parsed ATNF file:
        # Barycentric period of the pulsar (s)
        # Barycentric rotation frequency (Hz)
        # DM Dispersion measure (cm-3 pc)
        # W10 Width of pulse at 10% (ms).
        # W50 Width of pulse at 50% of peak (ms).

        ATNF_NAMES = []
        ATNF_RAJS = []
        ATNF_DECJS = []
        ATNF_PERIODS = []
        ATNF_FREQS   = []
        ATNF_DMS     = []
        ATNF_W10S    = []
        ATNF_W50S    = []

        if self.parseATNFFile:
            # Read parsed pulsar catalog file, extract useful variables:
            # Period, Frequency, DM, pulse width
            self.atnfFile = open(self.atnfParsedPath, 'r')  # Read only access

            for line in self.atnfFile.readlines():

                components = line.rstrip('\n').split(",")

                if line.startswith("Name,"):
                    # Ingore header
                    pass

                else:
                                    # Input file format...
                    #
                    # Name,RA,DEC,GL,GB,Period (s),Frequency (Hz),DM,W10 (ms),W50 (ms)
                    #  |                                                         |
                    #  v                                                         v
                    #  0                                                         9  <- Index positions.
                    ATNF_NAMES.append(components[0])
                    ATNF_RAJS.append(components[1])
                    ATNF_DECJS.append(components[2])
                    # Break for GL
                    # Break for GB
                    ATNF_PERIODS.append(float(components[5]))
                    ATNF_FREQS.append(float(components[6]))
                    ATNF_DMS.append(float(components[7]))
                    ATNF_W10S.append(float(components[8]))
                    ATNF_W50S.append(float(components[9]))

            self.atnfFile.close()

            # Print some details of the data collected...
            print("\n\t+----- ATNF DATA -----+")
            print("\tPeriods parsed     : " + str(len(ATNF_PERIODS)) + " Mean: " + str(mean(ATNF_PERIODS)) +
                  " Min: " + str(min(ATNF_PERIODS)) + " Max: " + str(max(ATNF_PERIODS)) +
                  " Zero elements: " + str(len(ATNF_PERIODS) - count_nonzero(ATNF_PERIODS)))

            print("\tFrequencies parsed : " + str(len(ATNF_FREQS))   + " Mean: " + str(mean(ATNF_FREQS)) +
                  " Min: " + str(min(ATNF_FREQS)) + " Max: " + str(max(ATNF_FREQS)) +
                  " Zero elements: " + str(len(ATNF_FREQS) - count_nonzero(ATNF_FREQS)))

            print("\tDMs parsed         : " + str(len(ATNF_DMS)) + " Mean: " + str(mean(ATNF_DMS)) +
                  " Min: " + str(min(ATNF_DMS)) + " Max: " + str(max(ATNF_DMS)) +
                  " Zero elements: " + str(len(ATNF_DMS) - count_nonzero(ATNF_DMS)))

            print("\t10% Widths parsed  : " + str(len(ATNF_W10S))    + " Mean: " + str(mean(ATNF_W10S)) +
                  " Min: " + str(min(ATNF_W10S)) + " Max: " + str(max(ATNF_W10S)) +
                  " Zero elements: " + str(len(ATNF_W10S) - count_nonzero(ATNF_W10S)))

            print("\t50% Widths parsed  : " + str(len(ATNF_W50S))    + " Mean: " + str(mean(ATNF_W50S)) +
                  " Min: " + str(min(ATNF_W50S)) + " Max: " + str(max(ATNF_W50S)) +
                  " Zero elements: " + str(len(ATNF_W50S) - count_nonzero(ATNF_W50S)))

        # ****************************************
        #            Parse ARFF file
        # ****************************************

        ARFF_PERIODS = []
        ARFF_FREQS   = []
        ARFF_SNRS    = []
        ARFF_DMS     = []
        ARFF_WIDTHS  = []
        ARFF_DCYCLE  = []

        if os.path.isfile(self.arffParsedPath):

            # Now read the parsed ARFF file, extract the useful variables:
            # Period (ms),S/N,DM,Pulse Width (ms),Duty Cycle
            self.arffFile = open(self.arffParsedPath, 'r')  # Read only access

            # Variables we are looking for in the parsed ARFF file:
            # Barycentric period of the pulsar (ms)
            # S/N
            # DM Dispersion measure (cm-3 pc)
            # 'best' Pulse width from PDMP (ms).
            # Duty cycle.

            for line in self.arffFile.readlines():

                components = line.rstrip('\n').split(",")

                if line.startswith("Period (ms),"):
                    # Ignore header
                    pass

                else:
                    p0 = float(components[0])
                    ARFF_PERIODS.append(p0/1000)  # Divide by 1000 to get periods in seconds
                    ARFF_FREQS.append(1.0 / p0)
                    ARFF_SNRS.append(float(components[1]))
                    ARFF_DMS.append(float(components[2]))
                    ARFF_WIDTHS.append(float(components[3]))
                    ARFF_DCYCLE.append(float(components[4]))

            self.arffFile.close()

            # Print some details of the data collected...

            print("\n\t+----- ARFF DATA -----+")
            print("\tPeriods parsed     : " + str(len(ARFF_PERIODS)) + " Mean: " + str(mean(ARFF_PERIODS)) +
                  " Min: " + str(min(ARFF_PERIODS)) + " Max: " + str(max(ARFF_PERIODS)) +
                  " Zero elements: " + str(len(ARFF_PERIODS) - count_nonzero(ARFF_PERIODS)))

            print("\tFreqs. parsed      : " + str(len(ARFF_FREQS)) + " Mean: " + str(mean(ARFF_FREQS)) +
                  " Min: " + str(min(ARFF_FREQS)) + " Max: " + str(max(ARFF_FREQS)) +
                  " Zero elements: " + str(len(ARFF_FREQS) - count_nonzero(ARFF_FREQS)))

            print("\tS/Ns parsed        : " + str(len(ARFF_SNRS)) + " Mean: " + str(mean(ARFF_SNRS)) +
                  " Min: " + str(min(ARFF_SNRS)) + " Max: " + str(max(ARFF_SNRS)) +
                  " Zero elements: " + str(len(ARFF_SNRS) - count_nonzero(ARFF_SNRS)))

            print("\tDMs parsed         : " + str(len(ARFF_DMS)) + " Mean: " + str(mean(ARFF_DMS)) +
                  " Min: " + str(min(ARFF_DMS)) + " Max: " + str(max(ARFF_DMS)) +
                  " Zero elements: " + str(len(ARFF_DMS) - count_nonzero(ARFF_DMS)))

            print("\tWidths parsed      : " + str(len(ARFF_WIDTHS)) + " Mean: " + str(mean(ARFF_WIDTHS)) +
                  " Min: " + str(min(ARFF_WIDTHS)) + " Max: " + str(max(ARFF_WIDTHS)) +
                  " Zero elements: " + str(len(ARFF_WIDTHS) - count_nonzero(ARFF_WIDTHS)))

            print("\tDuty cycles parsed : " + str(len(ARFF_DCYCLE)) + " Mean: " + str(mean(ARFF_DCYCLE)) +
                  " Min: " + str(min(ARFF_DCYCLE)) + " Max: " + str(max(ARFF_DCYCLE)) +
                  " Zero elements: " + str(len(ARFF_DCYCLE) - count_nonzero(ARFF_DCYCLE)))

        # ****************************************
        #
        #
        #
        #         Generating data samples
        #
        #
        #
        # ****************************************

        # Now create the distributions.

        print("\n\t+----- Fitting Distributions -----+")

        # ****************************************
        #              Pulse Periods
        # ****************************************

        print("\n\t1.1 Generating " + str(self.samples) + " period samples...")

        if self.autoGenerate:
            generatedPeriods = self.generateData(self.p0Dist, self.p0DistParams, self.samples)

            if self.verbose:
                print("\t1.1.1 Creating histogram for period samples...")
                plt.hist(generatedPeriods, bins=self.freedmanDiaconisRule(generatedPeriods), color='w')
                plt.title("Histogram of Generated Periods (" + str(self.p0Dist) + " distribution)")
                plt.xlabel("Period (s)")
                plt.ylabel("Frequency")
                plt.show()
        else:
            # Sample pulse periods from a uniform distribution based upon data in the supplied file.
            if len(ARFF_PERIODS) > 0:

                min_period = min(ARFF_PERIODS)
                max_period = max(ARFF_PERIODS)
                generatedPeriods = random.uniform(min_period, max_period, self.samples)

                # Plot histogram to show randomly generated period data points,
                # if verbose logging enabled... data should be uniformly distributed.
                if self.verbose:
                    print("\t1.1.1 Creating histogram for period samples...")
                    ARFF_Period_Histogram = plt.hist(generatedPeriods, bins=self.freedmanDiaconisRule(generatedPeriods),
                                                     color='w')
                    plt.title("Histogram of Uniformly Generated Periods")
                    plt.xlabel("Period (s)")
                    plt.ylabel("Frequency")
                    plt.show()

                # Now compute some stats describing generated data
                if self.verbose:
                    print("\t1.1.2 Creating box-plot for generated and observed period samples...")
                    print("\t1.1.3 Boxplot parameters...")
                    print("\t\tGenerated Data:")
                    print("\t\t\tMin    : " + str(min(generatedPeriods)))
                    print("\t\t\tMax    : " + str(max(generatedPeriods)))
                    print("\t\t\tMedian : " + str(median(generatedPeriods)))
                    print("\t\t\tSTDEV  : " + str(std(generatedPeriods)))
                    q75, q25 = percentile(generatedPeriods, [75, 25])
                    print("\t\t\tIQR    : " + str(q75 - q25))
                    print("\t\t\tRange  : " + str(max(generatedPeriods) - min(generatedPeriods)))
                    print("\t\tObserved Data:")
                    print("\t\t\tMin    : " + str(min(ARFF_PERIODS)))
                    print("\t\t\tMax    : " + str(max(ARFF_PERIODS)))
                    print("\t\t\tMedian : " + str(median(ARFF_PERIODS)))
                    print("\t\t\tSTDEV  : " + str(std(ARFF_PERIODS)))
                    q75, q25 = percentile(ARFF_PERIODS, [75, 25])
                    print("\t\t\tIQR    : " + str(q75 - q25))
                    print("\t\t\tRange  : " + str((max(ARFF_PERIODS) - min(ARFF_PERIODS))))

                    data = [generatedPeriods, ARFF_PERIODS]
                    plt.boxplot(data, notch=0, sym='+', vert=1, whis=1.5)
                    plt.title("Box-plot for generated and observed period samples")
                    plt.xticks([1, 2], ["Generated", "Observed"])
                    plt.ylabel("Period (s)")
                    #plt.yscale('log')
                    plt.ylim([min_period + (0.2 * min_period), max_period + (0.2 * max_period)])
                    plt.show()
            else:
                print("Could not get sample period data from parsed ARFF file!")
                print("\tExiting...")
                sys.exit()

        # ****************************************
        #           Dispersion Measure
        # ****************************************

        print("\n\t2.1 Generating " + str(self.samples) + " DM samples...")

        if self.autoGenerate:
            generatedDMs = self.generateData(self.dmDist, self.dmDistParams, self.samples)

            if self.verbose:
                print("\t1.1.1 Creating histogram for DM samples...")
                plt.hist(generatedDMs, bins=self.freedmanDiaconisRule(generatedDMs), color='w')
                plt.title("Histogram of Generated DMs (" + self.dmDist + " distribution)")
                plt.xlabel("DM")
                plt.ylabel("Frequency")
                plt.show()
        else:
            # Sample pulse periods from a uniform distribution based upon data in the supplied file.
            if len(ARFF_DMS) > 0:

                # Now fit exponential distribution to the DMs observed.
                print("\n\n\t2.1. Fitting exponential to ARFF DM data...")
                min_dm = 0
                max_dm = max(ARFF_DMS)

                loc, scale = stats.expon.fit(ARFF_DMS, floc=0)
                x = arange(min_dm, int(max_dm)+1)  # x-axis data points, from zero to DM max.
                pdf_fitted = stats.expon.pdf(x, loc, scale)
                print("\t2.2. Exponential Fit Parameters:")
                print("\t\tLocation: " + str(loc) + " Scale: " + str(scale))

                if self.verbose:
                    print("\t2.2.1. Plotting PDF for exponential model...")
                    plt.plot(pdf_fitted)
                    plt.title("PDF of Exponential fitted to DM")
                    plt.xlabel("Dispersion measure (DM)")
                    plt.ylabel("Probability Density")
                    plt.show()

                # Now generate exponential samples.
                print("\t2.3. Generating " + str(self.samples) + " DM samples from fitted exponential PDF...")
                generatedDMs = stats.expon.rvs(loc, scale, self.samples)

                if self.verbose:
                    print("\t2.3.1. Creating histogram for DM samples...")
                    ARFF_DM_Histogram = plt.hist(generatedDMs, bins=self.freedmanDiaconisRule(generatedDMs), color='w')
                    plt.title("Histogram of Exponentially generated DMs")
                    plt.xlabel("Dispersion measure (DM)")
                    plt.ylabel("Frequency")
                    plt.show()

                # Now compute some stats describing generated data
                if self.verbose:
                    print("\t1.1.2 Creating box-plot for generated and observed DM samples...")
                    print("\t1.1.3 Boxplot parameters...")
                    print("\t\tGenerated Data:")
                    print("\t\t\tMin    : " + str(min(generatedDMs)))
                    print("\t\t\tMax    : " + str(max(generatedDMs)))
                    print("\t\t\tMedian : " + str(median(generatedDMs)))
                    print("\t\t\tSTDEV  : " + str(std(generatedDMs)))
                    q75, q25 = percentile(generatedDMs, [75, 25])
                    print("\t\t\tIQR    : " + str(q75 - q25))
                    print("\t\t\tRange  : " + str(max(generatedDMs) - min(generatedDMs)))
                    print("\t\tObserved Data:")
                    print("\t\t\tMin    : " + str(min(ARFF_DMS)))
                    print("\t\t\tMax    : " + str(max(ARFF_DMS)))
                    print("\t\t\tMedian : " + str(median(ARFF_DMS)))
                    print("\t\t\tSTDEV  : " + str(std(ARFF_DMS)))
                    q75, q25 = percentile(ARFF_DMS, [75, 25])
                    print("\t\t\tIQR    : " + str(q75 - q25))
                    print("\t\t\tRange  : " + str(max(ARFF_DMS) - min(ARFF_DMS)))

                    data = [generatedDMs, ARFF_DMS]
                    plt.boxplot(data, notch=0, sym='+', vert=1, whis=1.5)
                    plt.title("Box-plot for generated and observed DM samples")
                    plt.xticks([1, 2], ["Generated", "Observed"])
                    plt.ylabel("Dispersion measure")
                    #plt.yscale('log')
                    plt.ylim([-10, max_dm + (0.2 * max_dm)])
                    plt.show()
            else:
                print("Could not get sample DM data from parsed ARFF file!")
                print("\tExiting...")
                sys.exit()

        # ****************************************
        #              Duty Cycles
        # ****************************************

        print("\n\n\t3.1. Generating " + str(self.samples) + " duty cycle samples...")

        if self.autoGenerate:
            generatedDutyCycles = self.generateData(self.dutyDist, self.dutyDistParams, self.samples)

            if self.verbose:
                print("\t1.1.1 Creating histogram for duty cycle samples...")
                plt.hist(generatedDutyCycles, bins=self.freedmanDiaconisRule(generatedDutyCycles), color='w')
                plt.title("Histogram of Generated duty cycles (" + str(self.dutyDist) + " distribution)")
                plt.xlabel("Duty cycle")
                plt.ylabel("Frequency")
                plt.show()
        else:
            # Sample pulse periods from a uniform distribution based upon data in the supplied file.
            if len(ARFF_DCYCLE) > 0:

                # Generate uniformly distributed duty cycles...
                min_duty = min(ARFF_DCYCLE)
                max_duty = max(ARFF_DCYCLE)
                generatedDutyCycles = random.uniform(min_duty, max_duty, self.samples) # 1000 periods between min and max values.

                # Plot histogram to show randomly generated period data points,
                # if verbose logging enabled... data should be uniformly distributed.
                if self.verbose:
                    print("\t3.1.1. Creating histogram for duty cycle samples...")
                    ARFF_DutyCycle_Histogram = plt.hist(generatedDutyCycles,
                                                        bins=self.freedmanDiaconisRule(generatedDutyCycles), color='w')
                    plt.title("Histogram of Uniformly Generated Duty Cycles")
                    plt.xlabel("Duty Cycle")
                    plt.ylabel("Frequency")
                    plt.show()

                # Now compute some stats describing generated data
                if self.verbose:
                    print("\t3.1.2 Creating box-plot for generated and observed Duty Cycles samples...")
                    print("\t3.1.3 Boxplot parameters...")
                    print("\t\tGenerated Data:")
                    print("\t\t\tMin    : " + str(min(generatedDutyCycles)))
                    print("\t\t\tMax    : " + str(max(generatedDutyCycles)))
                    print("\t\t\tMedian : " + str(median(generatedDutyCycles)))
                    print("\t\t\tSTDEV  : " + str(std(generatedDutyCycles)))
                    q75, q25 = percentile(generatedDutyCycles, [75, 25])
                    print("\t\t\tIQR    : " + str(q75 - q25))
                    print("\t\t\tRange  : " + str(max(generatedDutyCycles) - min(generatedDutyCycles)))
                    print("\t\tObserved Data:")
                    print("\t\t\tMin    : " + str(min(ARFF_DCYCLE)))
                    print("\t\t\tMax    : " + str(max(ARFF_DCYCLE)))
                    print("\t\t\tMedian : " + str(median(ARFF_DCYCLE)))
                    print("\t\t\tSTDEV  : " + str(std(ARFF_DCYCLE)))
                    q75, q25 = percentile(ARFF_DCYCLE, [75, 25])
                    print("\t\t\tIQR    : " + str(q75 - q25))
                    print("\t\t\tRange  : " + str(max(ARFF_DCYCLE) - min(ARFF_DCYCLE)))

                    data = [generatedDutyCycles, ARFF_DCYCLE]
                    plt.boxplot(data, notch=0, sym='+', vert=1, whis=1.5)
                    plt.title("Box-plot for generated and observed duty cycles samples")
                    plt.xticks([1, 2], ["Generated", "Observed"])
                    plt.ylabel("Duty Cycle")
                    #plt.yscale('log')
                    plt.ylim([-1, max_duty + (0.2 * max_duty)])
                    plt.show()

            else:
                print("Could not get sample duty cycle data from parsed ARFF file!")
                print("\tExiting...")
                sys.exit()
        # ****************************************
        #              Pulse Widths
        # ****************************************

        print("\n\n\t4.1. Generating Pulse widths based on duty cycle and period (Width = Duty Cycle x Period) ")

        # Generate widths based on: Width = Duty Cycle x Period.
        generatedWidths = []

        for dutyCycle, period in zip(generatedDutyCycles, generatedPeriods):
            generatedWidths.append(dutyCycle * period)

        if len(ARFF_WIDTHS) > 0:
            max_arff_width = max(ARFF_WIDTHS)
        else:
            max_arff_width = 0

        max_generated_width = max(generatedWidths)

        if max_generated_width > max_arff_width:
            max_width = max_generated_width
        else:
            max_width = max_arff_width

        # Plot histogram to show randomly generated width data points,
        # if verbose logging enabled...
        if self.verbose:
            print("\t4.1.1. Creating histogram for pulse width samples...")
            ARFF_Widths_Histogram = plt.hist(generatedWidths, bins=self.freedmanDiaconisRule(generatedWidths),
                                             color='b', label='Generated widths')
            plt.title("Histogram of Generated Pulse Widths (based on Width = Duty Cycle x Period)")
            plt.xlabel("Pulse Width (ms)")
            plt.ylabel("Frequency")
            plt.legend(loc='upper right')
            plt.show()

        # Now compute some stats describing generated data
        if self.verbose and self.autoGenerate == False:
            print("\t4.2.1 Creating box-plot for generated and observed Pulse Widths samples...")
            print("\t4.2.1 Boxplot parameters...")
            print("\t\tGenerated Data:")
            print("\t\t\tMin    : " + str(min(generatedWidths)))
            print("\t\t\tMax    : " + str(max(generatedWidths)))
            print("\t\t\tMedian : " + str(median(generatedWidths)))
            print("\t\t\tSTDEV  : " + str(std(generatedWidths)))
            q75, q25 = percentile(generatedWidths, [75, 25])
            print("\t\t\tIQR    : " + str(q75 - q25))
            print("\t\t\tRange  : " + str(max(generatedWidths) - min(generatedWidths)))
            print("\t\tObserved Data:")
            print("\t\t\tMin    : " + str(min(ARFF_WIDTHS)))
            print("\t\t\tMax    : " + str(max(ARFF_WIDTHS)))
            print("\t\t\tMedian : " + str(median(ARFF_WIDTHS)))
            print("\t\t\tSTDEV  : " + str(std(ARFF_WIDTHS)))
            q75, q25 = percentile(ARFF_WIDTHS, [75, 25])
            print("\t\t\tIQR    : " + str(q75 - q25))
            print("\t\t\tRange  : " + str(max(ARFF_WIDTHS) - min(ARFF_WIDTHS)))

            data = [generatedWidths, ARFF_WIDTHS]
            plt.boxplot(data, notch=0, sym='+', vert=1, whis=1.5)
            plt.title("Box-plot for generated and observed Pulse Widths samples")
            plt.xticks([1, 2], ["Generated", "Observed"])
            plt.ylabel("Pulse width (s)")
            #plt.yscale('log')
            plt.ylim([-1, max_width + (0.2 * max_width)])
            plt.show()

        # ****************************************
        #                  SNRS
        # ****************************************

        print("\n\n\t5.1. Generating " + str(self.samples) + " S/N samples...")

        if self.autoGenerate:
            generatedSNRs = self.generateData(self.snrDist, self.snrDistParams, self.samples)

            if self.verbose:
                print("\t5.1.1 Creating histogram for S/N samples...")
                plt.hist(generatedSNRs, bins=self.freedmanDiaconisRule(generatedSNRs), color='w')
                plt.title("Histogram of Generated S/Ns (" + str(self.snrDist) + " distribution)")
                plt.xlabel("S/N")
                plt.ylabel("Frequency")
                plt.show()
        else:

            if len(ARFF_SNRS) > 0:

                # Now fit exponential distribution to the DMs observed.
                print("\n\n\t5.1. Fitting exponential to ARFF S/N data...")
                min_snr = 0
                max_snr = max(ARFF_SNRS)
                loc, scale = stats.expon.fit(ARFF_SNRS, floc=0)
                x = arange(min_snr, int(max_snr)+1)  # x-axis data points, from zero to DM max.
                pdf_fitted = stats.expon.pdf(x, loc, scale)

                print("\t5.2. Exponential Fit Parameters:")
                print("\t\tLocation: " + str(loc) + " Scale: " + str(scale))

                if self.verbose:
                    print("\t5.2.1. Plotting PDF for exponential model...")
                    plt.plot(pdf_fitted)
                    plt.title("PDF of Exponential fitted to S/N")
                    plt.xlabel("S/N")
                    plt.ylabel("Probability Density")
                    plt.show()

                # Now generate exponential samples.
                print("\t5.3. Generating " + str(self.samples) + " S/N samples from fitted exponential PDF...")
                generatedSNRs = stats.expon.rvs(loc, scale, self.samples)

                # if verbose logging enabled... data should be uniformly distributed.
                if self.verbose:
                    print("\t5.1.1. Creating histogram for S/N samples...")
                    ARFF_SNR_Histogram = plt.hist(generatedSNRs, bins=self.freedmanDiaconisRule(generatedSNRs), color='w')
                    plt.title("Histogram of exponentially Generated S/Ns")
                    plt.xlabel("S/N")
                    plt.ylabel("Frequency")
                    plt.show()

                # Now compute some stats describing generated data
                if self.verbose:
                    print("\t5.1.2 Creating box-plot for generated and observed S/N samples...")
                    print("\t5.1.3 Boxplot parameters...")
                    print("\t\tGenerated Data:")
                    print("\t\t\tMin    : " + str(min(generatedSNRs)))
                    print("\t\t\tMax    : " + str(max(generatedSNRs)))
                    print("\t\t\tMedian : " + str(median(generatedSNRs)))
                    print("\t\t\tSTDEV  : " + str(std(generatedSNRs)))
                    q75, q25 = percentile(generatedSNRs, [75, 25])
                    print("\t\t\tIQR    : " + str(q75 - q25))
                    print("\t\t\tRange  : " + str(max(generatedSNRs) - min(generatedSNRs)))
                    print("\t\tObserved Data:")
                    print("\t\t\tMin    : " + str(min(ARFF_SNRS)))
                    print("\t\t\tMax    : " + str(max(ARFF_SNRS)))
                    print("\t\t\tMedian : " + str(median(ARFF_SNRS)))
                    print("\t\t\tSTDEV  : " + str(std(ARFF_SNRS)))
                    q75, q25 = percentile(ARFF_SNRS, [75, 25])
                    print("\t\t\tIQR    : " + str(q75 - q25))
                    print("\t\t\tRange  : " + str(max(ARFF_SNRS) - min(ARFF_SNRS)))

                    data = [generatedSNRs, ARFF_SNRS]
                    plt.boxplot(data, notch=0, sym='+', vert=1, whis=1.5)
                    plt.title("Box-plot for generated and observed S/N samples")
                    plt.xticks([1, 2], ["Generated", "Observed"])
                    plt.ylabel("S/N")
                    #plt.yscale('log')
                    plt.ylim([-1, max_snr + (0.2 * max_snr)])
                    plt.show()

            else:
                print("Could not get sample S/N data from parsed ARFF file!")
                print("\tExiting...")
                sys.exit()

        # Now check data has been generated correctly
        canProceed = True

        if len(generatedPeriods) == self.samples:
            print("\n\n\tAll period data generated")
        else:
            print("\n\n\tNot all period data generated!")
            canProceed = False

        if len(generatedDMs) == self.samples:
            print("\n\n\tAll DM data generated")
        else:
            print("\n\n\tNot all DM data generated!")
            canProceed = False

        if len(generatedDutyCycles) == self.samples:
            print("\n\n\tAll duty cycle data generated")
        else:
            print("\n\n\tNot all duty cycle data generated!")
            canProceed = False

        if len(generatedSNRs) == self.samples:
            print("\n\n\tAll S/N data generated")
        else:
            print("\n\n\tNot all S/N data generated!")
            canProceed = False

        if canProceed is False:
            print("Cannot proceed as not all data has been generated!")
            print("\tExiting...")
            sys.exit()

        # ****************************************
        #            Save data to file
        # ****************************************

        print("\n\n\tWriting data to the output file...")
        for period, dm, pulseWidth, dutyCycle, snr in zip(generatedPeriods, generatedDMs,
                                                          generatedWidths, generatedDutyCycles,
                                                          generatedSNRs):

            text = str(period) + "," + str(dm) + "," + str(pulseWidth) + "," + str(dutyCycle) + "," + str(snr) + "\n"
            self.appendToFile(self.outputPath, text)

        # ****************************************
        #
        #
        #
        #         Generating PAR files
        #
        #
        #
        # ****************************************

        # Example .PAR file...
        # PSRJ           	J0835-4510
        # RAJ            	08:35:20.61149           2.000e-05
        # DECJ           	-45:10:34.8751           3.000e-04
        # DM             	67.99                    1.000e-02
        # PEPOCH         	56000.0
        # F0             	11.1946499395            5.000e-10
        # TZRMJD          56000.0
        # TZRFREQ         1000.0
        # UNITS          	TDB

        # ****************************************
        #            Create pulsar pars
        # ****************************************

        if self.parseATNFFile:
            atnf_name_count  = len(ATNF_NAMES)
            atnf_rajs_count  = len(ATNF_RAJS)
            atnf_decjs_count = len(ATNF_DECJS)
            atnf_dms_count   = len(ATNF_DMS)
            atnf_freqs_count = len(ATNF_FREQS)

            if(atnf_name_count > 0 and atnf_rajs_count > 0 and atnf_decjs_count > 0
               and atnf_dms_count > 0 and atnf_freqs_count > 0):

                if(atnf_name_count == atnf_rajs_count and atnf_rajs_count == atnf_decjs_count and
                   atnf_decjs_count == atnf_dms_count and atnf_dms_count == atnf_freqs_count):

                    # For each of the parameters needed to generate a single PAR file...
                    for name, ra, dec, dm,freq in zip(ATNF_NAMES, ATNF_RAJS,ATNF_DECJS,ATNF_DMS,ATNF_FREQS):
                        fileName = name + ".par"
                        parFilePath = self.pulsarParFileDir + "/" + fileName
                        self.clearFile(parFilePath)

                        parFileText  = "PSRJ\t\t\t"    + name         + "\n"
                        parFileText += "RAJ\t\t\t\t"   + ra           + "\t\t\t2.000e-05\n"
                        parFileText += "DECJ\t\t\t"    + dec          + "\t\t\t3.000e-04\n"
                        parFileText += "DM\t\t\t\t"    + str(dm)      + "\t\t\t\t1.000e-02\n"
                        parFileText += "PEPOCH\t\t\t"  + self.pepoch  + "\n"
                        parFileText += "F0\t\t\t\t"    + str(freq)    + "\t\t5.000e-10\n"
                        parFileText += "TZRMJD\t\t\t"  + self.tzrmjd  + "\n"
                        parFileText += "TZRFREQ\t\t\t" + self.tzrfreq + "\n"
                        parFileText += "UNITS\t\t\t"   + self.units

                        self.appendToFile(parFilePath, parFileText)
                else:
                    print("Unequal ATNF inputs for par file creation - some entries are missing data.")
            else:
                print("ATNF data not read, cannot create par files.")

        # ****************************************
        #          Create fake pulsar pars
        # ****************************************
        # this is so we can find signals in the fake pulsars we generate (i.e. know the periodicity, DM etc).
        # For each of the parameters needed to generate a single PAR file...
        counter = 1
        for dm, p0, snr in zip(generatedDMs, generatedPeriods, generatedSNRs):

            fileName = "FakePulsar_" + str(counter) + "_" + str("%.6f" % p0) + "_" + str("%.1f" % dm) +\
                       "_" + str("%.1f" % snr) + ".par"

            parFilePath = self.fakePulsarParFileDir + "/" + fileName
            self.clearFile(parFilePath)

            parFileText  = "PSRJ\t\t\t"    + "FakePulsar_"    + str(counter) + "\n"
            parFileText += "RAJ\t\t\t\t"   + "00:00:00"  + "\t\t\t2.000e-05\n"
            parFileText += "DECJ\t\t\t"    + "00:00:00"  + "\t\t\t3.000e-04\n"
            parFileText += "DM\t\t\t\t"    + str(dm)     + "\t\t1.000e-02\n"
            parFileText += "PEPOCH\t\t\t"  + self.pepoch + "\n"
            parFileText += "F0\t\t\t\t"    + str(1.0/p0) + "\t5.000e-10\n"
            parFileText += "TZRMJD\t\t\t"  + self.tzrmjd + "\n"
            parFileText += "TZRFREQ\t\t\t" + self.tzrfreq+ "\n"
            parFileText += "UNITS\t\t\t"   + self.units

            self.appendToFile(parFilePath, parFileText)
            counter += 1


        print("\n\tDone.\n")
        print("\n**************************************************************************\n")

    # ****************************************************************************************************

    ## Generates the required number of data samples, from the supplied distribution.
    #
    # These are the distributions that can be used
    #
    #   key         params                  Name
    #   beta        a, b, loc, scale        Beta dist.
    #   expon       loc, scale              exponential dist.
    #   gamma       shape, loc, scale       Gamma dist.
    #   logistic    loc, scale              logistic dist.
    #   lognorm     s, mean, sigma          log-normal dist.
    #   norm        loc, scale              normal dist.
    #   truncnorm   min, max,loc, scale     normal dist.
    #   rayleigh    loc, scale,             Rayleigh dist.
    #   uniform     min, max, size          uniform dist.
    #
    #  @param self The object pointer.
    #  @param dist The distribution to use (string).
    #  @param params The parameters to use to initialise the distribution (numerical list).
    #  @params samples The total number of samples to draw from the distribution.
    #  @ returns The samples drawn from the distribution as a list.
    def generateData(self, dist, params, samples):
        """
        Generates the required number of data samples, according to the supplied
        distribution and associated parameters.

        These are the distributions that can be used

        key         params                  Name
        beta        a, b, loc, scale        Beta dist.
        expon       loc, scale              exponential dist.
        gamma       shape, loc, scale       Gamma dist.
        logistic    loc, scale              logistic dist.
        lognorm     s, mean, sigma          log-normal dist.
        norm        loc, scale              normal dist.
        truncnorm   min, max,loc, scale     normal dist.
        rayleigh    loc, scale,             Rayleigh dist.
        uniform     min, max, size          uniform dist.

        Parameters
        ----------
        self : object
            The object pointer.
        dist : string
            The string identifier of the distribution to use.
        params : list or numpy.ndarray
            The list of parameters to use to initialise the specified distribution.
        samples : int
            The total number of samples to draw from the distribution.

        Returns
        -------
        list or numpy.ndarray
            The samples drawn from the distribution as a list.

        Examples
        --------


        >>> dist = "truncnorm"
        >>> params = [0,10,2,0.5]
        >>> samples = generateData(dist,params,1000)

        This would draw 1000 samples from a truncated normal distribution, with
        a minimum value of 0, maximum value of 10, a mean of 2, and standard deviation of 0.5.

        """
        data = []

        # These are the distributions that can be used
        #
        #   key         params                  Name
        #   beta        a, b, loc, scale        Beta dist.
        #   expon       loc, scale              exponential dist.
        #   gamma       shape, loc, scale       Gamma dist.
        #   logistic    loc, scale              logistic dist.
        #   lognorm     s, mean, sigma          log-normal dist.
        #   norm        loc, scale              normal dist.
        #   truncnorm   min, max,loc, scale     normal dist.
        #   rayleigh    loc, scale,             Rayleigh dist.
        #   uniform     min, max, size          uniform dist.

        try:

            # beta distribution
            if dist == "beta":
                data = stats.beta.rvs(params[0], params[1], loc=params[0], scale=params[1], size=samples)

            # Exponential distribution
            elif dist == "expon":
                # Need to make modulo
                data = stats.expon.rvs(loc=params[0], scale=params[1], size=samples)

            # Gamma distribution
            elif dist == "gamma":
                # Need to make modulo
                data = stats.gamma.rvs(params[0], loc=params[1], scale=params[2], size=samples)

            # Logistic distribution
            elif dist == "logistic":
                # Need to make modulo
                data = stats.logistic.rvs(loc=params[0], scale=params[1], size=samples)

            # Log normal distribution
            elif dist == "lognorm":
                # Need to make modulo
                data = stats.lognorm.rvs(params[0], loc=params[1], scale=params[2], size=samples)

            # Normal distribution
            elif dist == "norm":
                data = stats.norm.rvs(loc=params[0], scale=params[1], size=samples)

            # Truncated normal distribution
            elif dist == "truncnorm":

                lower = float(params[0])
                upper = float(params[1])
                mu    = float(params[2])
                sigma = float(params[3])
                data = stats.truncnorm.rvs((lower-mu)/sigma, (upper-mu)/sigma, loc=mu, scale=sigma, size=samples)

            # Rayleigh distribution
            elif dist == "rayleigh":
                data = stats.rayleigh.rvs(loc=params[0], scale=params[1], size=samples)

            # Uniform distribution
            elif dist == "uniform":
                data = stats.uniform.rvs(loc=params[0], scale=params[1], size=samples)

        except Exception as e:  # Catch *all* exceptions.
            print("\tError generating data using " + str(dist) + " distribution with parameters " + str(params) +
                  "\n\t" + str(sys.exc_info()[0]))

        return data

    # ******************************************************************************************

    ## Appends the provided text to the file at the specified path.
    #
    #  @param self The object pointer.
    #  @param path The full path to the file to write to.
    #  @param text The text to write to the output file.
    def appendToFile(self, path, text):
        """Appends the provided text to the file at the specified path.

        Parameters
        ----------
        self : object
            The object pointer.
        path : str
            The full path to the file to write to.
        text : str
            The text to write to the output file.

        Examples
        --------
        >>> appendToFile("/Users/rob/test.txt","This is my text")

        which will append the text "This is my text" to the file.
        """

        destinationFile = open(path, 'a')
        destinationFile.write(str(text))
        destinationFile.close()

    # ******************************************************************************************

    ## Clears the contents of the file at the specified path.
    #
    #  @param self The object pointer.
    #  @param path The full path to the file to clear.
    def clearFile(self, path):
        """Clears the contents of the file at the specified path.

        Parameters
        ----------
        self : object
            The object pointer.
        path : str
            The full path to the file to clear.

        Examples
        --------
        >>> clearFile("/Users/rob/test.txt")

        which will clear all text in the file.
        """
        open(path, 'w').close()

    # ******************************************************************************************

    ## Calculates the number of bins to use in a histogram according to the Freedman-Diaconis rule.
    #
    #  @param self The object pointer.
    #  @param data The data to find the 'optimal' number of histogram bins for.
    #  @returns the total number of bins to use when plotting the data in a histogram.
    def freedmanDiaconisRule(self, data):
        """
        Calculates the number of bins to use in a histogram according to the Freedman-Diaconis rule.

        Parameters
        ----------
        self : object
            The object pointer.
        data : list or numpy.ndarray
            The list containing numerical data for which the number of bins is to be computed.

        Returns
        -------
        int
            The total number of bins to use when plotting the data in a histogram.

        Examples
        --------

        >>> data=[1,2,3,4,5,7,5,3,2,1,1,2,3,12,22,12,3,4,5,6]
        >>> bins = freedmanDiaconisRule(data)

        """
        # interquartile range, Q3-Q1....
        iqr = stats.scoreatpercentile(data, 75) - stats.scoreatpercentile(data, 25)
        binwidth = 2 * iqr * pow(len(data), -0.3333333)

        if binwidth <= 0:
            binwidth = 60

        # calculate n bins
        rnge = max(data) - min(data)
        nbins = ceil(rnge / binwidth)

        if self.verbose:
            print("\t\tFreedman Diaconis Rule values for bins:")
            print("\t\t\tIQR: " + str(iqr))
            print("\t\t\tBin Width: " + str(binwidth))
            print("\t\t\tRange: " + str(rnge))
            print("\t\t\tNumber of bins: " + str(nbins))

        return int(nbins)

    # ****************************************************************************************************

if __name__ == '__main__':
    CandidateParGenerator().main()